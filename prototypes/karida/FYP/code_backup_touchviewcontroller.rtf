{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red100\green56\blue32;\red196\green26\blue22;
\red28\green0\blue207;\red170\green13\blue145;\red92\green38\blue153;\red46\green13\blue110;\red63\green110\blue116;
\red38\green71\blue75;}
\paperw11900\paperh16840\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab560
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0     \cf2 //\cf0 \
\cf2 //  TouchViewController.m\cf0 \
\cf2 //  RDPPrototype\cf0 \
\cf2 //\cf0 \
\cf2 //  Created by Karida on 18/01/2011.\cf0 \
\cf2 //  Copyright 2011 HKUST. All rights reserved.\cf0 \
\cf2 //\cf0 \
\
\cf3 #import \cf4 "TouchViewController.h"\cf3 \
\cf0 \
\cf3 #define ZOOM_STEP \cf5 1.5\cf3   \
\cf0 \
\cf6 @interface\cf0  TouchViewController (UtilityMethods)  \
- (\cf7 CGRect\cf0 )zoomRectForScale:(\cf6 float\cf0 )scale withCenter:(\cf7 CGPoint\cf0 )center;  \
\cf6 @end\cf0   \
\
\cf6 @implementation\cf0  TouchViewController\
\cf6 @synthesize\cf0  swipeLeftRecognizer, tapRecognizer, longPressRecognizer, imageScrollView, imageView;\
\
\cf2 // The designated initializer.  Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad.\cf0 \
\cf2 /*\
- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil \{\
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];\
    if (self) \{\
        // Custom initialization.\
    \}\
    return self;\
\}\
 */\cf0 \
\
- (\cf6 void\cf0 )viewDidLoad \{\
	[\cf6 super\cf0  \cf8 viewDidLoad\cf0 ];\
	\
	\cf2 /*\
	\
	UIImage *tmpImage = [[UIImage imageNamed:@"Windows.png"] retain];\
	UIImageView *anImageView = [[UIImageView alloc] initWithImage:tmpImage];\
	anImageView.userInteractionEnabled = YES;\
	//[anImageView sizeToFit];\
	self.imageView = anImageView;\
	[anImageView release];\
	[self.view addSubview:imageView];\
	\
	UIGestureRecognizer *recognizer;\
	\
	\
	/*\
	 Create a tap recognizer and add it to the view.\
	 Keep a reference to the recognizer to test in gestureRecognizer:shouldReceiveTouch:.\
	 \
	recognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapFrom:)];\
	[self.view addGestureRecognizer:recognizer];\
	self.tapRecognizer = (UITapGestureRecognizer *)recognizer;\
	recognizer.delegate = self;\
	[recognizer release];\
	\
	/*\
	 Create a swipe gesture recognizer to recognize right swipes (the default).\
	 We're only interested in receiving messages from this recognizer, and the view will take ownership of it, so we don't need to keep a reference to it.\
	 \
	recognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipeFrom:)];\
	[self.view addGestureRecognizer:recognizer];\
	[recognizer release];\
	\
	/*\
	 Create a swipe gesture recognizer to recognize left swipes.\
	 Keep a reference to the recognizer so that it can be added to and removed from the view in takeLeftSwipeRecognitionEnabledFrom:.\
	 Add the recognizer to the view if the segmented control shows that left swipe recognition is allowed.\
	 \
	recognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipeFrom:)];\
	self.swipeLeftRecognizer = (UISwipeGestureRecognizer *)recognizer;\
	swipeLeftRecognizer.direction = UISwipeGestureRecognizerDirectionLeft;\
	\
	//if ([segmentedControl selectedSegmentIndex] == 0) \{\
	//	[self.view addGestureRecognizer:swipeLeftRecognizer];\
	//\}\
	self.swipeLeftRecognizer = (UISwipeGestureRecognizer *)recognizer;\
	[recognizer release];\
	\
	/*\
	 Create a rotation gesture recognizer.\
	 We're only interested in receiving messages from this recognizer, and the view will take ownership of it, so we don't need to keep a reference to it.\
	 \
	recognizer = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(handleRotationFrom:)];\
	[self.view addGestureRecognizer:recognizer];\
	[recognizer release];\
	\
	// For illustrative purposes, set exclusive touch for the segmented control (see the ReadMe).\
	//[segmentedControl setExclusiveTouch:YES];\
	\
	/*\
	 Create an image view to display the gesture description.\
	UIImageView *anImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0.0, 0.0, 300.0, 75.0)];\
	anImageView.contentMode = UIViewContentModeCenter;\
	self.imageView = anImageView;\
	[anImageView release];\
	[self.view addSubview:imageView];\
	 \
\
	\
	\
	// long tap\
	\
	recognizer = [[ UILongPressGestureRecognizer alloc] initWithTarget:self.imageView action:@selector(handleLongPress:)];\
	//recognizer.delegate = self;\
	[self.imageView addGestureRecognizer:recognizer];\
	//self.longPressRecognizer = (UILongPressGestureRecognizer *)recognizer;\
	//self.longPressRecognizer.minimumPressDuration = 3.0;\
	[recognizer release];\
	 */\cf0 \
	\
	\cf9 imageScrollView\cf0 .\cf7 bouncesZoom\cf0  = \cf6 YES\cf0 ;  \
	\cf9 imageScrollView\cf0 .\cf7 delegate\cf0  = \cf6 self\cf0 ;  \
	\cf9 imageScrollView\cf0 .\cf7 clipsToBounds\cf0  = \cf6 YES\cf0 ;  \
	\
	\cf9 imageView\cf0  = [[\cf7 UIImageView\cf0  \cf8 alloc\cf0 ] \cf8 initWithImage\cf0 :[\cf7 UIImage\cf0  \cf8 imageNamed\cf0 :\cf4 @"Windows.png"\cf0 ]];  \
	\cf9 imageView\cf0 .\cf7 userInteractionEnabled\cf0  = \cf6 YES\cf0 ;  \
	\cf9 imageView\cf0 .\cf7 autoresizingMask\cf0  = ( \cf8 UIViewAutoresizingFlexibleWidth\cf0  );  \
	[\cf9 imageScrollView\cf0  \cf8 addSubview\cf0 :\cf9 imageView\cf0 ];  \
	\
	\cf9 imageScrollView\cf0 .\cf7 contentSize\cf0  = [\cf9 imageView\cf0  \cf8 frame\cf0 ].\cf7 size\cf0 ;  \
	\
	\cf2 // add gesture recognizers to the image view  \cf0 \
	\cf7 UITapGestureRecognizer\cf0  *singleTap = [[\cf7 UITapGestureRecognizer\cf0  \cf8 alloc\cf0 ] \cf8 initWithTarget\cf0 :\cf6 self\cf0  \cf8 action\cf0 :\cf6 @selector\cf0 (\cf10 handleSingleTap\cf0 :)];  \
	\cf7 UITapGestureRecognizer\cf0  *doubleTap = [[\cf7 UITapGestureRecognizer\cf0  \cf8 alloc\cf0 ] \cf8 initWithTarget\cf0 :\cf6 self\cf0  \cf8 action\cf0 :\cf6 @selector\cf0 (\cf10 handleDoubleTap\cf0 :)];  \
	\cf7 UITapGestureRecognizer\cf0  *twoFingerTap = [[\cf7 UITapGestureRecognizer\cf0  \cf8 alloc\cf0 ] \cf8 initWithTarget\cf0 :\cf6 self\cf0  \cf8 action\cf0 :\cf6 @selector\cf0 (\cf10 handleTwoFingerTap\cf0 :)];  \
	\
	[doubleTap \cf8 setNumberOfTapsRequired\cf0 :\cf5 2\cf0 ];  \
	[twoFingerTap \cf8 setNumberOfTouchesRequired\cf0 :\cf5 2\cf0 ];  \
	\
	[\cf9 imageView\cf0  \cf8 addGestureRecognizer\cf0 :singleTap];  \
	[\cf9 imageView\cf0  \cf8 addGestureRecognizer\cf0 :doubleTap];  \
	[\cf9 imageView\cf0  \cf8 addGestureRecognizer\cf0 :twoFingerTap];  \
	\
	[singleTap \cf8 release\cf0 ];  \
	[doubleTap \cf8 release\cf0 ];  \
	[twoFingerTap \cf8 release\cf0 ];  \
	\
	\cf2 // calculate minimum scale to perfectly fit image width, and begin at that scale  \cf0 \
	\cf6 float\cf0  minimumScale = [\cf9 imageScrollView\cf0  \cf8 frame\cf0 ].\cf7 size\cf0 .\cf7 width\cf0   / [\cf9 imageView\cf0  \cf8 frame\cf0 ].\cf7 size\cf0 .\cf7 width\cf0 ;  \
	\cf2 //imageScrollView.maximumZoomScale = 1.0;  \cf0 \
	\cf9 imageScrollView\cf0 .\cf7 minimumZoomScale\cf0  = minimumScale;  \
	\cf9 imageScrollView\cf0 .\cf7 zoomScale\cf0  = minimumScale;  \
\}\
\
\
\
- (\cf6 BOOL\cf0 )shouldAutorotateToInterfaceOrientation:(\cf7 UIInterfaceOrientation\cf0 )\cf7 interfaceOrientation\cf0  \{\
    \cf2 // Overriden to allow any orientation.\cf0 \
    \cf6 return\cf0  \cf6 YES\cf0 ;\
\}\
\
\
- (\cf6 void\cf0 )didReceiveMemoryWarning \{\
    \cf2 // Releases the view if it doesn't have a superview.\cf0 \
    [\cf6 super\cf0  \cf8 didReceiveMemoryWarning\cf0 ];\
    \
    \cf2 // Release any cached data, images, etc. that aren't in use.\cf0 \
\}\
\
\
- (\cf6 void\cf0 )viewDidUnload \{\
    [\cf6 super\cf0  \cf8 viewDidUnload\cf0 ];\
    \cf2 // Release any retained subviews of the main view.\cf0 \
    \cf2 // e.g. self.myOutlet = nil;\cf0 \
	\
	\cf2 //self.segmentedControl = nil;\cf0 \
	\cf6 self\cf0 .\cf9 tapRecognizer\cf0  = \cf6 nil\cf0 ;\
	\cf6 self\cf0 .\cf9 swipeLeftRecognizer\cf0  = \cf6 nil\cf0 ;\
	\cf6 self\cf0 .\cf7 imageView\cf0  = \cf6 nil\cf0 ;\
	\cf6 self\cf0 .\cf9 imageScrollView\cf0  = \cf6 nil\cf0 ; \
	\
\}\
\
\cf3 #pragma mark UIScrollViewDelegate methods  \
\cf0 \
- (\cf7 UIView\cf0  *)viewForZoomingInScrollView:(\cf7 UIScrollView\cf0  *)scrollView \{  \
	\cf6 return\cf0  \cf9 imageView\cf0 ;  \
\}  \
\
\cf3 #pragma mark TapDetectingImageViewDelegate methods  \
\cf0 \
- (\cf6 void\cf0 )handleSingleTap:(\cf7 UIGestureRecognizer\cf0  *)gestureRecognizer \{  \
	\cf2 // single tap does nothing for now  \cf0 \
\}  \
\
- (\cf6 void\cf0 )handleDoubleTap:(\cf7 UIGestureRecognizer\cf0  *)gestureRecognizer \{  \
	\cf2 // zoom in  \cf0 \
	\cf6 float\cf0  newScale = [\cf9 imageScrollView\cf0  \cf8 zoomScale\cf0 ] * \cf3 ZOOM_STEP\cf0 ;  \
	\cf7 CGRect\cf0  zoomRect = [\cf6 self\cf0  \cf10 zoomRectForScale\cf0 :newScale \cf10 withCenter\cf0 :[gestureRecognizer \cf8 locationInView\cf0 :gestureRecognizer.\cf8 view\cf0 ]];  \
	[\cf9 imageScrollView\cf0  \cf8 zoomToRect\cf0 :zoomRect \cf8 animated\cf0 :\cf6 YES\cf0 ];  \
\}  \
\
- (\cf6 void\cf0 )handleTwoFingerTap:(\cf7 UIGestureRecognizer\cf0  *)gestureRecognizer \{  \
	\cf2 // two-finger tap zooms out  \cf0 \
	\cf6 float\cf0  newScale = [\cf9 imageScrollView\cf0  \cf8 zoomScale\cf0 ] / \cf3 ZOOM_STEP\cf0 ;  \
	\cf7 CGRect\cf0  zoomRect = [\cf6 self\cf0  \cf10 zoomRectForScale\cf0 :newScale \cf10 withCenter\cf0 :[gestureRecognizer \cf8 locationInView\cf0 :gestureRecognizer.\cf8 view\cf0 ]];  \
	[\cf9 imageScrollView\cf0  \cf8 zoomToRect\cf0 :zoomRect \cf8 animated\cf0 :\cf6 YES\cf0 ];  \
\}  \
\
\cf3 #pragma mark Utility methods  \
\cf0 \
- (\cf7 CGRect\cf0 )zoomRectForScale:(\cf6 float\cf0 )scale withCenter:(\cf7 CGPoint\cf0 )center \{  \
	\
	\cf7 CGRect\cf0  zoomRect;  \
	\
	\cf2 // the zoom rect is in the content view's coordinates.   \cf0 \
	\cf2 //    At a zoom scale of 1.0, it would be the size of the imageScrollView's bounds.  \cf0 \
	\cf2 //    As the zoom scale decreases, so more content is visible, the size of the rect grows.  \cf0 \
	zoomRect.\cf7 size\cf0 .\cf7 height\cf0  = [\cf9 imageScrollView\cf0  \cf8 frame\cf0 ].\cf7 size\cf0 .\cf7 height\cf0  / scale;  \
	zoomRect.\cf7 size\cf0 .\cf7 width\cf0   = [\cf9 imageScrollView\cf0  \cf8 frame\cf0 ].\cf7 size\cf0 .\cf7 width\cf0   / scale;  \
	\
	\cf2 // choose an origin so as to get the right center.  \cf0 \
	zoomRect.\cf7 origin\cf0 .\cf7 x\cf0     = center.\cf7 x\cf0  - (zoomRect.\cf7 size\cf0 .\cf7 width\cf0   / \cf5 2.0\cf0 );  \
	zoomRect.\cf7 origin\cf0 .\cf7 y\cf0     = center.\cf7 y\cf0  - (zoomRect.\cf7 size\cf0 .\cf7 height\cf0  / \cf5 2.0\cf0 );  \
	\
	\cf6 return\cf0  zoomRect;  \
\}  \
\
\
\cf2 /*\
- (IBAction)takeLeftSwipeRecognitionEnabledFrom:(UISegmentedControl *)aSegmentedControl \{\
	NSLog(@"leftSwipe");    \
\}\
\
\
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch \{\
	\
    // Disallow recognition of tap gestures in the segmented control.\
	// if ((touch.view == segmentedControl) && (gestureRecognizer == tapRecognizer)) \{\
    //    return NO;\
	// \}\
    return YES;\
\}\
\
\
\
\
#pragma mark -\
#pragma mark Responding to gestures\
\
- (void)showImageWithText:(NSString *)string atPoint:(CGPoint)centerPoint \{\
	\
    /*\
     Set the appropriate image for the image view, move the image view to the given point, then dispay it by setting its alpha to 1.0.\
     \
	NSString *imageName = [string stringByAppendingString:@".png"];\
	imageView.image = [UIImage imageNamed:imageName];\
	imageView.center = centerPoint;\
	imageView.alpha = 1.0;	\
\}\
\
/*\
 In response to a tap gesture, show the image view appropriately then make it fade out in place.\
 \
- (void)handleTapFrom:(UITapGestureRecognizer *)recognizer \{\
	\
	CGPoint location = [recognizer locationInView:self.view];\
	[self showImageWithText:@"tap" atPoint:location];\
	\
	[UIView beginAnimations:nil context:NULL];\
	[UIView setAnimationDuration:0.5];\
	imageView.alpha = 0.0;\
	[UIView commitAnimations];\
	\
	[self.view removeFromSuperview];\
\}\
\
/*\
 In response to a rotation gesture, show the image view at the rotation given by the recognizer, then make it fade out in place while rotating back to horizontal.\
 \
- (void)handleRotationFrom:(UIRotationGestureRecognizer *)recognizer \{\
	\
	CGPoint location = [recognizer locationInView:self.view];\
    \
    CGAffineTransform transform = CGAffineTransformMakeRotation([recognizer rotation]);\
    imageView.transform = transform;\
	[self showImageWithText:@"rotation" atPoint:location];\
    \
	[UIView beginAnimations:nil context:NULL];\
	[UIView setAnimationDuration:0.65];\
	imageView.alpha = 0.0;\
    imageView.transform = CGAffineTransformIdentity;\
	[UIView commitAnimations];\
\}\
\
-(void) handleLongPress:(UILongPressGestureRecognizer *)recognizer  \{\
	NSLog(@"LongTap");  \
\}\
*/\cf0 \
\
\
- (\cf6 void\cf0 )dealloc \{\
	[\cf9 tapRecognizer\cf0  \cf8 release\cf0 ];\
	[\cf9 swipeLeftRecognizer\cf0  \cf8 release\cf0 ];\
	[\cf9 imageView\cf0  \cf8 release\cf0 ];\
	[\cf9 imageScrollView\cf0  \cf8 release\cf0 ];\
    [\cf6 super\cf0  \cf8 dealloc\cf0 ];\
\}\
\
\
\cf6 @end\cf0 \
}